"""Template generation for login API nodes."""

from __future__ import annotations

from typing import Iterable, Sequence

from .utils import ensure_identifier, join_lines, property_literal, quote_string, to_snake_case

HEADER = "// Generated by Workflow Agent template-first workflow (sprint 6).\n"
SUPPORTED_METHODS = {"get", "post", "put", "delete", "patch"}


def build_login_api_files(
    *,
    node_id: str,
    method: str,
    path: str,
    auth_strategy: str,
    fields: Sequence[object],
    source_ids: Sequence[str],
    language: str,
) -> list[tuple[str, str]]:
    is_ts = language.upper() == "TS"
    route_method = method.lower()
    if route_method not in SUPPORTED_METHODS:
        route_method = "post"

    safe_path = _normalise_path(path)
    file_stem = to_snake_case(node_id, fallback="login_api")
    extension = "ts" if is_ts else "js"
    target_path = f"backend/src/routes/{file_stem}.{extension}"

    payload_type_name = ensure_identifier(f"{node_id}Payload", fallback="LoginPayload")
    content = _render_api_module(
        node_id=node_id,
        route_method=route_method,
        http_method=method.upper(),
        path=safe_path,
        auth_strategy=auth_strategy,
        fields=list(fields),
        source_ids=list(source_ids),
        payload_type_name=payload_type_name,
        is_ts=is_ts,
    )

    header = join_lines(
        [
            HEADER.rstrip("\n"),
            f"// Source node: {node_id}",
            f"// HTTP method: {method.upper()} {safe_path}",
            "",
        ]
    )
    return [(target_path, header + content)]


def _render_api_module(
    *,
    node_id: str,
    route_method: str,
    http_method: str,
    path: str,
    auth_strategy: str,
    fields: Sequence[object],
    source_ids: Sequence[str],
    payload_type_name: str,
    is_ts: bool,
) -> str:
    required_names, optional_names = _partition_fields(fields)
    lines: list[str] = []

    if is_ts:
        lines.append('import type { Request, Response } from "express";')
    lines.append('import { Router } from "express";')
    lines.append("")
    lines.append("const router = Router();")
    if source_ids:
        sources = ", ".join(source_ids)
        lines.append(f"// Form sources: {sources}")
    lines.append("")
    lines.extend(
        _render_field_constants(
            required_names=required_names,
            optional_names=optional_names,
            payload_type_name=payload_type_name,
            is_ts=is_ts,
        )
    )
    lines.append("")
    lines.extend(
        _render_helpers(
            payload_type_name=payload_type_name,
            is_ts=is_ts,
        )
    )
    lines.append("")
    lines.extend(
        _render_handler(
            route_method=route_method,
            path=path,
            auth_strategy=auth_strategy,
            http_method=http_method,
            is_ts=is_ts,
        )
    )
    lines.append("")
    lines.append("export default router;")

    return join_lines(lines)


def _render_field_constants(
    *,
    required_names: Sequence[str],
    optional_names: Sequence[str],
    payload_type_name: str,
    is_ts: bool,
) -> list[str]:
    lines: list[str] = []
    required_literal = _string_literal_list(required_names)
    optional_literal = _string_literal_list(optional_names)

    if is_ts:
        lines.append(f"const REQUIRED_FIELDS = {required_literal} as const;")
        lines.append(f"const OPTIONAL_FIELDS = {optional_literal} as const;")
        lines.append("type RequiredField = (typeof REQUIRED_FIELDS)[number];")
        lines.append("type OptionalField = (typeof OPTIONAL_FIELDS)[number];")
        lines.append("type FieldName = RequiredField | OptionalField;")
        lines.append(f"type {payload_type_name} = {{")
        if not required_names and not optional_names:
            lines.append("  // Define request fields here.")
        for name in required_names:
            lines.append(f"  {property_literal(name)}: string;")
        for name in optional_names:
            lines.append(f"  {property_literal(name)}?: string;")
        lines.append("};")
    else:
        lines.append(f"const REQUIRED_FIELDS = {required_literal};")
        lines.append(f"const OPTIONAL_FIELDS = {optional_literal};")

    return lines


def _render_helpers(*, payload_type_name: str, is_ts: bool) -> list[str]:
    lines: list[str] = []
    if is_ts:
        lines.append(f"function pickPayload(req: Request): Partial<{payload_type_name}> {{")
    else:
        lines.append("function pickPayload(req) {")
    lines.append('  const source = req.method === "GET" ? req.query : req.body;')
    lines.append("  if (!source || typeof source !== \"object\") {")
    lines.append("    return {};")
    lines.append("  }")
    if is_ts:
        lines.append(f"  return source as Partial<{payload_type_name}>;")
    else:
        lines.append("  return source;")
    lines.append("}")
    lines.append("")
    if is_ts:
        lines.append(f"function collectMissingFields(payload: Partial<{payload_type_name}>): RequiredField[] {{")
    else:
        lines.append("function collectMissingFields(payload) {")
    lines.append("  return REQUIRED_FIELDS.filter((field) => {")
    lines.append("    const value = payload[field];")
    lines.append("    if (value === undefined || value === null) {")
    lines.append("      return true;")
    lines.append("    }")
    lines.append("    if (typeof value === \"string\") {")
    lines.append("      return value.trim().length === 0;")
    lines.append("    }")
    lines.append("    return String(value).trim().length === 0;")
    lines.append("  });")
    lines.append("}")
    lines.append("")
    if is_ts:
        lines.append(f"function normalisePayload(payload: Partial<{payload_type_name}>): Record<string, string> {{")
    else:
        lines.append("function normalisePayload(payload) {")
    if is_ts:
        lines.append("  const result: Record<string, string> = {};")
    else:
        lines.append("  const result = {};")
    lines.append("  for (const field of REQUIRED_FIELDS) {")
    lines.append("    result[field] = String(payload[field] ?? \"\");")
    lines.append("  }")
    lines.append("  for (const field of OPTIONAL_FIELDS) {")
    lines.append("    if (payload[field] !== undefined && payload[field] !== null) {")
    lines.append("      result[field] = String(payload[field]);")
    lines.append("    }")
    lines.append("  }")
    lines.append("  return result;")
    lines.append("}")
    return lines


def _render_handler(
    *,
    route_method: str,
    path: str,
    auth_strategy: str,
    http_method: str,
    is_ts: bool,
) -> list[str]:
    payload_extract = "const payload = pickPayload(req);"
    lines: list[str] = []
    handler_signature = (
        f"router.{route_method}({quote_string(path)}, async (req: Request, res: Response) => {{"
        if is_ts
        else f"router.{route_method}({quote_string(path)}, async (req, res) => {{"
    )
    lines.append(handler_signature)
    lines.append(f"  // HTTP method enforced: {http_method}")
    lines.append(f"  {payload_extract}")
    lines.append("  const missing = collectMissingFields(payload);")
    lines.append("")
    lines.append("  if (missing.length > 0) {")
    lines.append("    res.status(400).json({")
    lines.append('      error: "Missing required fields.",')
    lines.append("      fields: missing,")
    lines.append("    });")
    lines.append("    return;")
    lines.append("  }")
    lines.append("")
    if auth_strategy and auth_strategy.lower() != "none":
        lines.append(f"  // TODO: enforce {auth_strategy} authentication.")
    lines.append("  const responseBody = normalisePayload(payload);")
    lines.append("")
    lines.append("  res.status(200).json({")
    lines.append('    message: "Login API stub executed.",')
    lines.append("    data: responseBody,")
    lines.append("  });")
    lines.append("});")
    return lines


def _partition_fields(fields: Sequence[object]) -> tuple[list[str], list[str]]:
    required: list[str] = []
    optional: list[str] = []
    seen: set[str] = set()
    for field in fields:
        name = str(getattr(field, "name", "")).strip()
        if not name or name in seen:
            continue
        seen.add(name)
        if bool(getattr(field, "required", False)):
            required.append(name)
        else:
            optional.append(name)
    return required, optional


def _string_literal_list(values: Iterable[str]) -> str:
    items = [quote_string(value) for value in values]
    return "[" + ", ".join(items) + "]"


def _normalise_path(path: str) -> str:
    if not path:
        return "/"
    return path if path.startswith("/") else f"/{path}"
