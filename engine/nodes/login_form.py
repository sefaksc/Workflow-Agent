"""Template generation for login form nodes."""

from __future__ import annotations

from collections.abc import Mapping, Sequence

from .utils import (
    bool_literal,
    ensure_identifier,
    join_lines,
    property_literal,
    quote_string,
    to_pascal_case,
    to_snake_case,
)

MUI_STYLE_KEYS = {"materialui", "material-ui", "mui"}
HEADER = "// Generated by Workflow Agent template-first workflow (sprint 6).\n"


def build_login_form_files(
    *,
    node_id: str,
    fields: Sequence[Mapping[str, object]],
    style_library: str,
    validation_mode: str,
    language: str,
) -> list[tuple[str, str]]:
    is_ts = language.upper() == "TS"
    component_name = ensure_identifier(node_id, fallback="LoginForm")
    file_stem = to_pascal_case(node_id) or component_name
    extension = "tsx" if is_ts else "jsx"
    path = f"frontend/src/components/{file_stem}.{extension}"

    renderer = (
        _render_material_ui_form
        if style_library.strip().lower() in MUI_STYLE_KEYS
        else _render_plain_form
    )

    content = renderer(
        component_name=component_name,
        original_id=node_id,
        fields=list(fields),
        validation_mode=validation_mode,
        is_ts=is_ts,
    )

    header = join_lines([HEADER.rstrip("\n"), f"// Source node: {node_id}", ""])
    return [(path, header + content)]


def _render_material_ui_form(
    *,
    component_name: str,
    original_id: str,
    fields: Sequence[Mapping[str, object]],
    validation_mode: str,
    is_ts: bool,
) -> str:
    slug = to_snake_case(original_id, fallback="login_form")
    lines: list[str] = []
    lines.append('import { useState } from "react";')
    if is_ts:
        lines.append('import type { ChangeEvent, FormEvent } from "react";')
    lines.append('import { Button, Stack, TextField } from "@mui/material";')
    lines.append("")
    lines.extend(_render_field_metadata(fields, is_ts))
    lines.append("")
    lines.extend(_render_initial_state(component_name, fields, is_ts))
    lines.append("")
    lines.extend(
        _render_component_body(
            component_name=component_name,
            slug=slug,
            validation_mode=validation_mode,
            is_ts=is_ts,
            uses_mui=True,
        )
    )
    return join_lines(lines)


def _render_plain_form(
    *,
    component_name: str,
    original_id: str,
    fields: Sequence[Mapping[str, object]],
    validation_mode: str,
    is_ts: bool,
) -> str:
    slug = to_snake_case(original_id, fallback="login_form")
    lines: list[str] = []
    lines.append('import { useState } from "react";')
    if is_ts:
        lines.append('import type { ChangeEvent, FormEvent } from "react";')
    lines.append("")
    lines.extend(_render_field_metadata(fields, is_ts))
    lines.append("")
    lines.extend(_render_initial_state(component_name, fields, is_ts))
    lines.append("")
    lines.extend(
        _render_component_body(
            component_name=component_name,
            slug=slug,
            validation_mode=validation_mode,
            is_ts=is_ts,
            uses_mui=False,
        )
    )
    return join_lines(lines)


def _render_field_metadata(fields: Sequence[Mapping[str, object]], is_ts: bool) -> list[str]:
    field_entries: list[str] = []
    for field in fields:
        name = str(field.get("name") or "field")
        label = str(field.get("label") or name)
        input_type = str(field.get("inputType") or "text")
        required = bool(field.get("required"))
        parts = [
            f"name: {quote_string(name)}",
            f"label: {quote_string(label)}",
            f"type: {quote_string(input_type)}",
            f"required: {bool_literal(required)}",
        ]
        auto_complete = _format_auto_complete(field)
        if auto_complete:
            parts.append(auto_complete)
        field_entries.append("  { " + ", ".join(parts) + " },")

    if not field_entries:
        field_entries = [
            (
                '  { name: "username", label: "Username", type: "text", '
                'required: true, autoComplete: "username" },'
            )
        ]

    closing = "] as const;" if is_ts else "];"
    return ["const formFields = [", *field_entries, closing]


def _render_initial_state(
    component_name: str,
    fields: Sequence[Mapping[str, object]],
    is_ts: bool,
) -> list[str]:
    lines: list[str] = []
    if is_ts:
        lines.append('type FieldName = (typeof formFields)[number]["name"];')
        lines.append("")
        lines.append("type FormValues = Record<FieldName, string>;")
        lines.append("")
        lines.append(f"export interface {component_name}Props {{")
        lines.append("  onSubmit?: (values: FormValues) => void;")
        lines.append("}")
        lines.append("")
        lines.append("const initialValues: FormValues = {")
    else:
        lines.append("const initialValues = {")

    entries = [
        f"  {property_literal(str(field.get('name')))}: \"\","
        for field in fields
    ]
    if not entries:
        entries = ['  username: "",']
    lines.extend(entries)
    lines.append("};")
    lines.append("")
    if is_ts:
        lines.append("const requiredFieldNames: FieldName[] = formFields")
    else:
        lines.append("const requiredFieldNames = formFields")
    lines.append("  .filter((field) => field.required)")
    lines.append("  .map((field) => field.name);")
    lines.append("")
    return lines


def _render_component_body(
    *,
    component_name: str,
    slug: str,
    validation_mode: str,
    is_ts: bool,
    uses_mui: bool,
) -> list[str]:
    lines: list[str] = []
    if is_ts:
        lines.append(
            f"export function {component_name}({{ onSubmit }}: {component_name}Props): "
            "JSX.Element {"
        )
    else:
        lines.append(f"export function {component_name}({{ onSubmit }}) {{")
    if is_ts:
        lines.append("  const [values, setValues] = useState<FormValues>(() => {")
    else:
        lines.append("  const [values, setValues] = useState(() => {")
    lines.append("    return { ...initialValues };")
    lines.append("  });")
    if is_ts:
        lines.append("  const [errors, setErrors] = useState<FieldName[]>([]);")
    else:
        lines.append("  const [errors, setErrors] = useState([]);")
    lines.append("")
    if is_ts:
        lines.append(
            "  const handleChange = (field: FieldName) => "
            "(event: ChangeEvent<HTMLInputElement>) => {"
        )
    else:
        lines.append("  const handleChange = (field) => (event) => {")
    lines.append("    setValues((previous) => ({ ...previous, [field]: event.target.value }));")
    lines.append("  };")
    lines.append("")
    if is_ts:
        lines.append("  const handleSubmit = (event: FormEvent<HTMLFormElement>) => {")
    else:
        lines.append("  const handleSubmit = (event) => {")
    lines.append("    event.preventDefault();")
    lines.append(
        "    const missing = requiredFieldNames.filter("
        "(field) => values[field].trim().length === 0"
        ");"
    )
    lines.append("    if (missing.length > 0) {")
    lines.append("      setErrors(missing);")
    lines.append("      return;")
    lines.append("    }")
    lines.append("    setErrors([]);")
    lines.append(f"    // Validation mode: {validation_mode}")
    lines.append("    onSubmit?.(values);")
    lines.append("  };")
    lines.append("")
    if is_ts:
        lines.append("  const hasError = (name: FieldName) => errors.includes(name);")
    else:
        lines.append("  const hasError = (name) => errors.includes(name);")
    lines.append("")
    lines.append("  return (")
    lines.append("    <form onSubmit={handleSubmit} noValidate>")
    if uses_mui:
        lines.append("      <Stack spacing={2}>")
        lines.extend(_render_mui_fields())
        lines.append("        <Button type=\"submit\" variant=\"contained\">")
        lines.append("          Submit")
        lines.append("        </Button>")
        lines.append("      </Stack>")
    else:
        lines.extend(_render_plain_fields(slug=slug))
        lines.append("      <button type=\"submit\" className=\"wf-button\">")
        lines.append("        Submit")
        lines.append("      </button>")
    lines.append("    </form>")
    lines.append("  );")
    lines.append("}")
    return lines


def _render_mui_fields() -> list[str]:
    return [
        "        {formFields.map((field) => (",
        "          <TextField",
        "            key={field.name}",
        "            label={field.label}",
        "            type={field.type}",
        "            required={field.required}",
        "            value={values[field.name]}",
        "            onChange={handleChange(field.name)}",
        "            autoComplete={field.autoComplete ?? undefined}",
        "            error={hasError(field.name)}",
        "            helperText={hasError(field.name) ? \"This field is required.\" : undefined}",
        "            fullWidth",
        "          />",
        "        ))}",
    ]


def _render_plain_fields(*, slug: str) -> list[str]:
    return [
        "      <div className=\"wf-form-grid\">",
        "        {formFields.map((field) => (",
        "          <div key={field.name} className=\"wf-form-field\">",
        f"            <label htmlFor={{`${{field.name}}-{slug}`}}>{{field.label}}</label>",
        "            <input",
        f"              id={{`${{field.name}}-{slug}`}}",
        "              name={field.name}",
        "              type={field.type}",
        "              required={field.required}",
        "              autoComplete={field.autoComplete ?? undefined}",
        "              value={values[field.name]}",
        "              onChange={handleChange(field.name)}",
        "            />",
        "            {hasError(field.name) ? (",
        "              <p className=\"wf-form-error\">This field is required.</p>",
        "            ) : null}",
        "          </div>",
        "        ))}",
        "      </div>",
    ]


def _format_auto_complete(field: Mapping[str, object]) -> str | None:
    hint = field.get("autoComplete")
    if isinstance(hint, str) and hint.strip():
        return f'autoComplete: {quote_string(hint.strip())}'
    return None
